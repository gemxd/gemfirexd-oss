apply plugin: 'wrapper'

buildscript {
  repositories {
    maven { url "https://plugins.gradle.org/m2" }
    jcenter()
  }
  dependencies {
    classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.2'
  }
}

allprojects {
  // We want to see all test results.  This is equivalent to setting --continue
  // on the command line.
  gradle.startParameter.continueOnFailure = true

  repositories {
    jcenter()
    maven { url 'http://repo.spring.io/release' }
    maven { url 'http://repo.spring.io/milestone' }
    maven { url 'http://repo.spring.io/snapshot' }
    maven { url 'http://repo.spring.io/libs-release' }
    maven { url 'http://repo.spring.io/ext-release-local' }
    maven { url 'https://dl.bintray.com/big-data/maven' }
  }

  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Tar).each { tar ->
      tar.compression = Compression.GZIP
      tar.extension = 'tar.gz'
    }
  })

  ext {
    scalaBinaryVersion = '2.10'
    scalaVersion = scalaBinaryVersion + '.6'
    springVersion = '3.2.12.RELEASE'
    log4jVersion = '1.2.17'
    slf4jVersion = '1.7.12'
    junitVersion = '4.11'
    antVersion = '1.8.4'
    pxfVersion = '2.5.1.0'
    osgiVersion = '6.0.0'
    jettyVersion = '8.1.14.v20131031'
    hadoopVersion = '2.4.1'
    hbaseVersion = '0.94.27'
    derbyVersion = '10.10.2.0'
    //hbaseVersion = '0.94.4-gemfire-r45047'
    //hadoopVersion = '2.2.0-gphd-3.1.0.0'
    //hadoopVersion = '2.4.1-gphd-3.2.0.0-54'

    // product and release properties
    PRODUCT_NAME = 'SnappyData'

    GEMFIRE_PRODUCT = 'Pivotal GemFire'
    GEMFIRE_VERSION = '7.5.Beta'

    PRODUCT_MAJOR = '2'
    PRODUCT_MINOR = '0'
    PRODUCT_MAINT = 'SNAPSHOT.1'
    PRODUCT_VERSION = "${PRODUCT_MAJOR}.${PRODUCT_MINOR}-${PRODUCT_MAINT}"
    PRODUCT_VENDOR = 'Pivotal Software, Inc.'
    COPYRIGHT = "Copyright 1997-2015, ${PRODUCT_VENDOR} All rights reserved."

    if (rootProject.name == 'snappy-store') {
      subprojectBase = ':'
      gitCmd = "git --git-dir=${rootDir}/.git --work-tree=${rootDir}"
    } else {
      subprojectBase = ':snappy-store:'
      gitCmd = "git --git-dir=${project(':snappy-store').projectDir}/.git --work-tree=${project(':snappy-store').projectDir}"
    }

    gitBranch = "${gitCmd} rev-parse --abbrev-ref HEAD".execute().text.trim()
    commitId = "${gitCmd} rev-parse HEAD".execute().text.trim()
    sourceDate = "${gitCmd} log -n 1 --format=%ai".execute().text.trim()

    osArch = System.getProperty('os.arch')
    osName = org.gradle.internal.os.OperatingSystem.current()
    osVersion = System.getProperty('os.version')
    buildDate = new Date().format('yyyy-MM-dd HH:mm:ss Z')
    buildNumber = new Date().format('MMddyy')
    jdkVersion = System.getProperty('java.version')
  }

  buildRoot = buildRoot.trim()
  def osDir = osName.getFamilyName().toLowerCase()
  if (!buildRoot.isEmpty()) {
    buildDir = new File(buildRoot, osDir + '/' +  project.path.replace(':', '/'))
  } else {
    buildDir = 'build-artifacts/' + osDir
  }

  ext {
    if (rootProject.name == 'snappy-store') {
      testResultsBase = "${rootProject.buildDir}/tests"
    } else {
      testResultsBase = "${rootProject.buildDir}/tests/store"
    }
  }

  group = 'org.pivotal.gemfirexd'
  version = PRODUCT_VERSION

  apply plugin: 'java'
  apply plugin: 'maven'
  apply plugin: 'idea'
  apply plugin: 'eclipse'
}

def writeProperties(def parent, def name, def comment, def propsMap) {
  parent.exists() || parent.mkdirs()
  def writer = new File(parent, name).newWriter()
  def props = new Properties()
  propsMap.each { k, v -> props.setProperty(k, v.toString()) }
  try {
    props.store(writer, comment.toString())
    writer.flush()
  } finally {
    writer.close()
  }
}

def writeTestProperties(def parent, def name) {
  def availablePortFinder = AvailablePortFinder.createPrivate()
  writeProperties(new File(parent, name), 'gemfire.properties',
      'Autogenerated Gemfire properties', [
      'mcast-port': Integer.toString(availablePortFinder.nextAvailable),
      'log-level': 'config' ])
}

def getManifest(def symname, def imports, def exports, def otherAttrs) {
  def attrs = [
    "Manifest-Version"        : "1.0",
    "Title"                   : PRODUCT_NAME,
    "Bundle-Name"             : "${PRODUCT_NAME} ${PRODUCT_VERSION}",
    "Bundle-Version"          : PRODUCT_VERSION,
    "Bundle-Vendor"           : PRODUCT_VENDOR,
    "Bundle-SymbolicName"     : symname,
    "Bundle-ActivationPolicy" : "lazy",
    "Bundle-NativeCode"       : "com/sun/jna/win32-x86/jnidispatch.dll; processor=x86;osname=win32, com/sun/jna/win32-x86-64/jnidispatch.dll; processor=x86-64;osname=win32, com/sun/jna/w32ce-arm/jnidispatch.dll; processor=arm;osname=wince,  com/sun/jna/sunos-x86/libjnidispatch.so; processor=x86;osname=sunos, com/sun/jna/sunos-x86-64/libjnidispatch.so; processor=x86-64;osname=sunos, com/sun/jna/sunos-sparc/libjnidispatch.so; processor=sparc;osname=sunos, com/sun/jna/sunos-sparcv9/libjnidispatch.so; processor=sparcv9;osname=sunos,  com/sun/jna/aix-ppc/libjnidispatch.a; processor=ppc;osname=aix, com/sun/jna/aix-ppc64/libjnidispatch.a; processor=ppc64;osname=aix,  com/sun/jna/linux-ppc/libjnidispatch.so; processor=ppc;osname=linux, com/sun/jna/linux-ppc64/libjnidispatch.so; processor=ppc64;osname=linux, com/sun/jna/linux-x86/libjnidispatch.so; processor=x86;osname=linux, com/sun/jna/linux-x86-64/libjnidispatch.so; processor=x86-64;osname=linux, com/sun/jna/linux-arm/libjnidispatch.so; processor=arm;osname=linux, com/sun/jna/linux-ia64/libjnidispatch.so; processor=ia64;osname=linux,  com/sun/jna/freebsd-x86/libjnidispatch.so; processor=x86;osname=freebsd, com/sun/jna/freebsd-x86-64/libjnidispatch.so; processor=x86-64;osname=freebsd, com/sun/jna/openbsd-x86/libjnidispatch.so; processor=x86;osname=openbsd, com/sun/jna/openbsd-x86-64/libjnidispatch.so; processor=x86-64;osname=openbsd,  com/sun/jna/darwin/libjnidispatch.jnilib; osname=macosx;processor=x86;processor=x86-64;processor=ppc",
    "DynamicImport-Package"   : imports,
    "Export-Package"          : exports
  ]
  attrs.putAll(otherAttrs)
  return attrs
}

def generateCommonManifest(def pdir, def bdir) {
  def ddir = "${bdir}/resources/main/META-INF/"
  def fdir = new File(ddir)
  fdir.exists() || fdir.mkdirs()
  copy {
    from "${pdir}/.."
    into ddir
    include 'LICENSE*'
    include 'NOTICE*'
  }
}

def replaceRegex(def fileDir, def fileName, def regex, def replacement) {
  def tmpDir = "${buildDir}/tmp"
  def filePath = "${fileDir}/${fileName}"
  copy {
    from filePath
    into tmpDir
    filter { line ->
      line.replaceAll(regex, replacement)
    }
  }
  file("${tmpDir}/${fileName}").renameTo(file(filePath))
}

def getStackTrace(def t) {
  java.io.StringWriter sw = new java.io.StringWriter()
  java.io.PrintWriter pw = new java.io.PrintWriter(sw)
  org.codehaus.groovy.runtime.StackTraceUtils.sanitize(t).printStackTrace(pw)
  return sw.toString()
}

task cleanStoreJUnit << {
  def workingDir = "${testResultsBase}/junit"
  delete workingDir
  file(workingDir).mkdirs()
}

subprojects {
  // apply compiler options
  sourceCompatibility = 1.7
  targetCompatibility = 1.7

  compileJava.options.encoding = 'UTF-8'
  javadoc.options.charSet = 'UTF-8'

  configurations {
    provided {
      description 'a dependency that is provided externally at runtime'
      visible true
    }

    testOutput {
      extendsFrom testCompile
      description  'a dependency that exposes test artifacts'
    }
  }

  // Here we want to disable all transitive dependencies on external artifacts.  This
  // allows us to lock down library versions.  However, we want project dependencies to
  // be transitive such that the libraries of a dependent project are automatically included.
  configurations.all {
    dependencies.all { dep ->
      if (dep instanceof ModuleDependency && !(dep instanceof ProjectDependency)) {
        dep.transitive = false
      }
    }
    resolutionStrategy {
      // fail eagerly on version conflict (includes transitive dependencies)
      // e.g. multiple different versions of the same dependency (group and name are equal)
      failOnVersionConflict()
    }
  }

  eclipse {
    classpath {
      defaultOutputDir = file('build-eclipse')
      plusConfigurations += [ configurations.provided ]     
    }
    // Several files have UTF-8 encoding and Eclipse running on Windows
    // will have trouble unless we tell it to use UTF-8 encoding.
    // This setting needs to go into the core.resources.prefs file,
    // which the JDT script isn't set up to configure
    eclipseJdt << {
      File f = file('.settings/org.eclipse.core.resources.prefs')
      f.write('eclipse.preferences.version=1\n')
      f.append('encoding/<project>=utf-8')
    }
  }

  cleanEclipse << {
    delete '.settings/org.eclipse.core.resources.prefs'
  }

  idea {
    module {
      scopes.PROVIDED.plus += [ configurations.provided ]
    }
  }

  task jarTest (type: Jar, dependsOn: testClasses) {
    description 'Assembles a jar archive of test classes.'
    from sourceSets.test.output
    classifier 'test'
  }

  artifacts {
    testOutput jarTest
  }

  sourceSets {
    main.compileClasspath += configurations.provided
    main.runtimeClasspath -= configurations.provided
    test.compileClasspath += configurations.provided
    test.runtimeClasspath += configurations.provided
  }

  javadoc.classpath += configurations.provided

  dependencies {
    provided 'com.google.code.findbugs:annotations:3.0.0'
    compile "log4j:log4j:${log4jVersion}"
    compile "org.slf4j:slf4j-api:${slf4jVersion}"
    compile "org.slf4j:slf4j-log4j12:${slf4jVersion}"

    testCompile "junit:junit:${junitVersion}"
    testCompile 'org.hamcrest:hamcrest-core:1.1'
    testCompile 'org.hamcrest:hamcrest-library:1.1'
    testCompile 'org.jmock:jmock:2.5.1'
    testCompile 'org.jmock:jmock-legacy:2.5.1'
    testCompile 'edu.umd.cs.mtc:multithreadedtc:1.01'
    testRuntime 'cglib:cglib-nodep:2.1_3'
    testRuntime 'org.objenesis:objenesis:1.0'
  }

  test {
    //maxParallelForks = (2 * Runtime.getRuntime().availableProcessors())

    include '**/*Test.class'
    exclude '**/*DUnitTest.class'
    exclude '**/*DUnit.class'
    exclude '**/derbyTesting/**'
    useJUnit {
      excludeCategories 'com.gemstone.junit.IntegrationTest'
      excludeCategories 'com.gemstone.junit.DistributedTest'
    }

    workingDir = "${testResultsBase}/junit"
    delete workingDir
    file(workingDir).mkdirs()
    writeTestProperties(workingDir, '.')

    binResultsDir = file("${workingDir}/binary/${project.name}")
    reports.html.destination = file("${workingDir}/html/${project.name}")
    reports.junitXml.destination = file(workingDir)

    // run each test in its own vm to avoid interference issues if a test doesn't clean up
    // state
    //forkEvery 1
  }
  task integrationTest(type:Test) {
    maxParallelForks = (2 * Runtime.getRuntime().availableProcessors())

    include '**/*Test.class'
    exclude '**/*DUnitTest.class'
    exclude '**/*DUnit.class'
    useJUnit {
      includeCategories 'com.gemstone.junit.IntegrationTest'
      excludeCategories 'com.gemstone.junit.UnitTest'
      excludeCategories 'com.gemstone.junit.DistributedTest'
    }    

    workingDir = "${testResultsBase}/integration"
    delete workingDir
    file(workingDir).mkdirs()
    writeTestProperties(workingDir, '.')

    binResultsDir = file("${workingDir}/binary/${project.name}")
    reports.html.destination = file("${workingDir}/html/${project.name}")
    reports.junitXml.destination = file(workingDir)

    forkEvery 1
  }
  task distributedTest(type:Test) {
    maxParallelForks = Runtime.getRuntime().availableProcessors()

    include '**/*DUnitTest.class'
    include '**/*DUnit.class'

    workingDir = "${testResultsBase}/dunit"
    delete workingDir
    file(workingDir).mkdirs()
    writeTestProperties(workingDir, '.')

    binResultsDir = file("${workingDir}/binary/${project.name}")
    reports.html.destination = file("${workingDir}/html/${project.name}")
    reports.junitXml.destination = file(workingDir)

    //I'm hoping this might deal with SOME OOMEs I've seen
    forkEvery 30
  }

  // apply common test configuration
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Test).each { test ->
      check.dependsOn test
      test.configure {
        onlyIf { ! Boolean.getBoolean('skip.tests') }

        minHeapSize '128m'
        maxHeapSize '1g'
        jvmArgs = ['-XX:+HeapDumpOnOutOfMemoryError', '-XX:MaxPermSize=256M', '-ea']
        maxParallelForks = 1

        testLogging.exceptionFormat = 'full'

        systemProperties 'gemfire.DEFAULT_MAX_OPLOG_SIZE' : '10',
          'gemfire.disallowMcastDefaults'  : 'true',
          'java.net.preferIPv4Stack'       : 'true',
          'jline.terminal'                 : 'scala.tools.jline.UnsupportedTerminal',
          'gemfiretest.sourceDir'          : "${projectDir}/src/test/resources"

        if (rootProject.name == 'snappy-store') {
          def eol = System.getProperty('line.separator')
          beforeTest { desc ->
            def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
            def progress = new File(workingDir, "progress.txt")
            def output = new File(workingDir, "output.txt")
            progress << "${now} Starting test ${desc.className} ${desc.name}${eol}"
            output << "${now} STARTING TEST ${desc.className} ${desc.name}${eol}${eol}"
          }
          onOutput { desc, event ->
            def output = new File(workingDir, "output.txt")
            output  << event.message
          }
          afterTest { desc, result ->
            def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
            def progress = new File(workingDir, "progress.txt")
            def output = new File(workingDir, "output.txt")
            progress << "${now} Completed test ${desc.className} ${desc.name} with result: ${result.resultType}${eol}"
            output << "${eol}${now} COMPLETED TEST ${desc.className} ${desc.name} with result: ${result.resultType}${eol}${eol}"
            result.exceptions.each { t ->
              progress << "  EXCEPTION: ${getStackTrace(t)}${eol}"
              output << "${getStackTrace(t)}${eol}"
            }
          }
        }
      }
    }
  })

  test.dependsOn subprojectBase + 'cleanStoreJUnit'
  check.dependsOn integrationTest
  check.dependsOn distributedTest
}

test.dependsOn subprojects.collect { p -> p.getTasksByName('test', false).collect { it.path } }
check.dependsOn subprojects.collect { p -> p.getTasksByName('check', false).collect { it.path } }

task combineReports(type: TestReport) {
  description 'Combines the test reports.'
  destinationDir = file("${testResultsBase}/combined-reports")
}

gradle.taskGraph.whenReady({ graph ->
  tasks.getByName('combineReports').reportOn rootProject.subprojects.collect{ it.tasks.withType(Test) }.flatten()
})

task generateSources {
  dependsOn subprojectBase + 'gemfire-core:createVersionPropertiesFile'
  dependsOn subprojectBase + 'gemfirexd:generateSources'
}

def includeJar(def jarFile) {
  def jarName = jarFile.getName()
  return jarName.contains('jetty') || jarName.contains('spring') ||
    jarName.contains('hbase') || jarName.contains('pxf') ||
    jarName.contains('osgi') || jarName.contains('ant-') ||
    jarName.contains('jline')
}

// pack the entire GemFireXD product tree
task product(dependsOn: [ subprojectBase + 'gemfirexd:client:jar',
    subprojectBase + 'gemfirexd:core:jar',
    subprojectBase + 'gemfirexd:tools:jar',
    subprojectBase + 'tests-sql:jar',
    subprojectBase + 'gemfirexd:shared:javadoc',
    subprojectBase + 'gemfirexd:core:javadoc' ]) << {

  def productDir = file("${rootProject.buildDir}/store")
  delete productDir

  def sharedProject = project(subprojectBase + 'gemfirexd:shared')
  def clientProject = project(subprojectBase + 'gemfirexd:client')
  def gemcoreProject = project(subprojectBase + 'gemfire-core')
  def coreProject = project(subprojectBase + 'gemfirexd:core')
  def toolsProject = project(subprojectBase + 'gemfirexd:tools')

  def gcmDir = System.getProperty('GCMDIR', '/gcm')

  def extraJars = (gemcoreProject.configurations.provided - gemcoreProject.configurations.runtime +
        coreProject.configurations.provided - coreProject.configurations.runtime +
        toolsProject.configurations.provided - toolsProject.configurations.runtime).filter {
    includeJar(it)
  }
  // first copy the product and dependent jars
  copy {
    from(clientProject.jar.destinationDir) {
      include clientProject.jar.archiveName
    }
    from(coreProject.jar.destinationDir) {
      include coreProject.jar.archiveName
    }
    from(toolsProject.jar.destinationDir) {
      include toolsProject.jar.archiveName
    }
    from extraJars
    into "${productDir}/lib"
  }

  // next the scripts
  copy {
    from(toolsProject.projectDir.getAbsolutePath() + '/bin') {
      include 'gfxd'
      include 'color'
      include 'appdirector/gemfirexd*'
      include 'dataextractor'
      include 'dataextractloader'
      include 'gfxd-completion.bash'
      if (osName.isWindows()) {
        include 'gfxd.bat'
        include 'dataextractor.bat'
        include 'dataextractloader.bat'
      }
    }
    into "${productDir}/bin"
    filter { line ->
      line.replaceAll('__VERSION__', version)
    }
    fileMode 0755
  }

  // the native JNI library
  if (osName.isLinux()) {
    copy {
      from coreProject.projectDir.getAbsolutePath() + '/lib'
      into "${productDir}/lib"
    }
  }

  // examples, javadocs, vsd
  copy {
    from(project(subprojectBase + 'gemfirexd').projectDir.getAbsolutePath() + '/examples') {
      exclude 'src/main/java/mapreduce/README.txt'
      exclude 'src/main/java/mapreduce/pom.xml'
    }
    from(coreProject.projectDir.getAbsolutePath()) {
      include 'src/main/java/com/pivotal/gemfirexd/callbacks/DBSynchronizer.java'
      include 'src/main/java/com/pivotal/gemfirexd/callbacks/AsyncEventHelper.java'
    }
    into "${productDir}/examples"
  }
  copy {
    from(project(subprojectBase + 'gemfirexd').projectDir.getAbsolutePath() + '/examples') {
      include 'src/main/java/mapreduce/README.txt'
      include 'src/main/java/mapreduce/pom.xml'
    }
    into "${productDir}/examples"
    filter { line ->
      line.replaceAll('__VERSION__', version)
    }
  }
  copy {
    from project(subprojectBase + 'gemfirexd').projectDir.getAbsolutePath() + '/quickstart'
    into "${productDir}/quickstart"
  }
  copy {
    from "${gcmDir}/where/vsd/70/vsd"
    into "${productDir}/tools/vsd"
  }
  copy {
    from sharedProject.javadoc.destinationDir
    from coreProject.javadoc.destinationDir
    into "${productDir}/docs/japi"
  }
  copy {
    from(rootDir.getAbsolutePath() + '/release/images') {
      include 'GemFireXD_190x81.png'
    }
    from(rootDir.getAbsolutePath() + '/release/docfiles') {
      include 'copyright.html'
      include 'support.html'
      include 'DocIndex.css'
      include 'gfxd-index.html'
    }
    into "${productDir}/docs"
    rename 'gfxd-index.html', 'index.html'
  }
}
